
# 학습 목차
- Oracle Database 메모리 구조 및 DB 실행 순서  
- 실행계획
----

## Oracle Database 메모리 구조 및 DB 실행 순서

<img width="688" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/452c7578-19d1-467d-b612-c381552d2069">

>  메모리 부분에 생성되는 구조를 인스턴스(Instance)  
>    - 메모리에 생성되는 인스턴스는 크게 SGA (System Global Area) 백그라운드 프로세스 (Background Processes) 들로 나뉘어 집니다.  
>   데이터베이스(Database)  
>    - 데이터가 저장되는 부분을 데이터파일(Datafiles)  
>    - DB전체의 관리정보가 들어있는 컨트롤파일 (Controlfiles)  
>    - 장애 복구시 이용되는 리두 로그파일 (Redo log files)  

### 1. SGA(System Global Area)
 - 인스턴스에 대한 데이터와 제어 정보를 가지는 공유 메모리 영역의 집합
 - Oracle 서버를 동시에 사용하고 있는 사용자는 시스템 글로벌 영역의 데이터를 공유합니다.(모든 서버프로세스가 공유하여 사용)
 - 데이터를 디스크로부터 읽어 메모리로 적재한 후 Read/Write/Update/Delete 하는데 활용할 때 사용되는 메모리 공간
 
 - 구성
   - Database Buffer Cache
     - 디스크에서 읽어온 데이터를 저장하는 공간으로, 사용자가 조회 하거나 변경하려는 모든 데이터는 이 곳에 있어야 합니다.(데이터 캐시)
     - 유한한 자원을 여러 Process가 한꺼번에 사용하려고 할 경우 순서를 지키는 것이 중요한데, 이런 경우 순서를 관리하기 위해 Oracle은 Latch라는 것을 사용합니다.
     - 논리적 I/O , 물리적 I/O 그리고 버퍼캐시 히트율
        - 논리적 I/O : SQL을 처리하는 과정에서 발생한 총 블록 I/O
        - 물리적 I/O : 데이터가 Database Buffer Cache에 없어 디스크에서 발생한 총 블록 I/O
        - 버퍼캐시 히트율(BCHR) : 물리적 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율 (물리적I/O는 시스템상황에 의해 결정되어 통제가 불가능하므로 SQL성능을 높이기위해서는 논리적 I/O를 줄이는 일뿐)

   -  Redo Log buffer
     - 데이터에 변경사항이 생길 경우 (DDL이나 DML이 실행 된 경우) 해당 변경 내용을 기록해 두는 역할을 합니다.
     - Redo log buffer의 내용을 디스크에서 저장해 주는 파일을 Redo log file 이라고 부릅니다.

    -  Shared Pool(Permanent Area + Dynamic Area)
      - 고정 영역(Permanent Area) : SGA를 관리하는 파라미터 정보
      - 동적 영역(Dynamic Area) (Library Cache + Data Dictionary Cache)
        - Library Cache :  Soft Parse 할 때 사용 되는 공간으로 이미 수행 되었던 SQL문장이나 PL/SQL 문장의 Parse Code와 해당 PL/SQL 문장, 실행 계획 등이 저장되어 있고, LRU 알고리즘으로 관리됩니다.(코드캐시)
        - Data Dictionary Cache : 구문분석이나 옵티마이저가 실행계획을 세울 때 사용 되는 주요 Dictionary들이 Row 단위로 Cache 되어 있습니다. LRU 알고리즘으로 관리됩니다.
#### 1.1 SGA 실습

```sql
SHOW SGA;
----------------------------------------------------
Total System Global Area   6731022336 bytes      
Fixed Size                    2188488 bytes      
Variable Size              3674213176 bytes      
Database Buffers           3036676096 bytes      
Redo Buffers                 17944576 bytes 
```

### 2. PGA(Program Global Area)
- 각 Process마다 개별적으로 저장해야 할 내용을 담는 공간.(서버프로세스가 단독으로 사용)
- 주로 정렬 관련 작업등이 이루어진다.
- Server Process나 백그라운드 Process들은 전부 각각의 PGA를 가지고 각자의 용도에 맞게 사용.
- 유저로부터 요청받은 작업을 처리하는 데 사용되는 메모리 영역

- 구성
  - 정렬 공간 (Sort Area) : Order by, Group by 수행 시 정렬할 때 사용되는 공간, 메모리 부족 시 디스크 공간 활용
  - 세션 정보 (Session Information) : 서버 <-> 유저 연결 정보
  - 커서 상태 정보(Cursor State) : SQL 파싱 정보가 저장되어 있는 주소
  - 변수 저장 공간 (Stack Area) : Bind 변수를 저장하는 공간
  - 유저 프로세스 -> 서버 프로세스 -> PGA로 할당


### 3. SQL 문장의 실행 원리
1. 사용자 접근 (사용자가 SQL문장을 수행)  
   - 접근법 : CLI(SQL PLUS), GUI(SQL DEVELOPER, ..)을 통해 접근 (기본포트값 1521(리스터))

2. 사용자의 PC쪽에 USer Process라는 프로세스가 해당 SQL문장을 서버로 전달 후 결과값이 나오기까지 대기.  
3. User Process로부터 SQL문장을 받은 Server Process는 PGA 할당 후 SQL 파싱 진행  
   - SQL 파싱 
      - 1) 파싱 트리 생성 : SQL문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
      - 2) Syntax 체크 : 문법적 오류가 없는지 확인
      - 3) Semanitic 체크 : 의미상 오류가 없는지 확인
      - 4) 권한검사
4. Shared Pool에서 Library Cache를 검사.(캐시 존재시 소프트파싱, 없을시 하드파싱(sql최적화+로우소스생성))  
   - 기존 SQL 캐시에서 실행계획이 존재 한다면 실행 단계로 진행하고 (Soft Parse_소프트파싱),  
   - 없으면 옵티마이저를 찾아가 실행 계획을 만들어 달라고 요청. Data Dictionary등을 참조하여 옵티마이저가 실행 계획 생성(Hard Parse_하드파싱) _ 최적화 및 로우 생성 단계 거치는 것  
   - Soft Parse 실패시에만 Hard Parse 과정을 거침.  
  
  > SQL은 컴파일언어이므로 한자한자 인코딩하여 SQL 텍스트가 변하면 SQL ID도 변하여 다르게 처리한다  
  >   예1) select * From t1 과 Select * from t1을 다르게 처리한다. > **대소문자의 룰을 맞춰 나가야한다.**  
  >   에2) select * From t1 where id = 'java' 와 select * From t1 where id = 'oracle' 을 다르게 처리한다. > **바인드 변수의 중요성**  
  >        share pool에서 다르게 처리하여 새로 가져온다   
  > SQL ID도 변하여 다르게 처리되면 **하드파싱**으로 처리되므로 잘 처리해야함  
   
   
### 4. SQL SELECT 쿼리 실행 순서
  - 실행 순서 : FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY
  - where 과 having으로 조건을 걸때 결과 같이 같더라도 where에 거는것이 성능이 좋다 (처음에 걸러내는것이 양을 줄일수있다)
  - 테이블 별칭은 어디에서든 다 적용이 되고 컬럼 별칭은 나머지에서 해석이 안되지만 order by에서 읽힌다다 


### 5. Single Block I/O vs Multiblock I/O 
  - Single Block I/O : 한번에 한 블록씩 요청해서 메모리에 적제하는 방식
  - Multiblock I/O : 여러 블록씩 요청해서 메모리에 적재하는 방식(인덱스를 이용하지 않고 테이블 전체를 스캔할때 사용)
  

------------------------
## 실행계획
### 1.실행계획 옵션 설정 및 읽는 법 

- sql문 실행계획 실행 (단축키 : F5)
```sql
set autotrace on exp;
```

- 실행계획 순서는 좌측을 기준으로 들어가있는 것이 제일 먼저이고 같은 레이어면 위쪽이 먼저 실행된 것
```sql
SELECT STATEMENT              -- 3. 최종적으로 pga에 넘겨줌    
  TABLE ACCESS BY INDEX ROWID -- 2. rowid로 힙의 데이터를 찾음
   INDEX UNIQUE SCAN          -- 1. 인덱스를 탐
```

- 인덱스가 있더라도 액세스 양이 많아질 것으로 판단할 경우 옵티마이저가 full스캔으로 실행계획을 자동으로 변경할 수 있음


#### 1.1 실행계획 실습
> 제약조건은 인덱스가 걸리는 제약조건이다 

- 인덱스가 걸리지않은 heap의 상태
```sql
create table t1
( c1 int, 
  c2 int, 
  c3 int);
  ```

- c1, c2는 인덱스를 타고 c3는 heap으로 검색됨
```sql
create table t1
( c1 int primary key, 
  c2 int unique, 
  c3 int);
```


- 조건이 없어서 힙데이터로 탐색
```sql
select * from t1;
--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |     1 |    39 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS FULL| T1   |     1 |    39 |     2   (0)| 00:00:01 |
--------------------------------------------------------------------------
```

- c1(PK) 인덱스를 내려갈 계획을 짬
```sql
select * from t1 where c1=10;
--------------------------------------------------------------------------------------------
| Id  | Operation                   | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |              |     1 |    39 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| T1           |     1 |    39 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | SYS_C0011127 |     1 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
```

- c2인덱스(UK)를 내려갈 계획을 짬

```sql
select * from t1 where c2=10;
--------------------------------------------------------------------------------------------
| Id  | Operation                   | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |              |     1 |    39 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| T1           |     1 |    39 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | SYS_C0011128 |     1 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
```

- 힙데이터를 바라봄(C3는 인덱스 존재 X)
```sql
select * from t1 where c3=10;
--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |     1 |    39 |     2   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| T1   |     1 |    39 |     2   (0)| 00:00:01 |
--------------------------------------------------------------------------
```


 -------------------------------------------------------------------------------
 ### 2. 테이블 데이터 복사 
 > 데이터만 복사하고 제약조건, 인덱스는 복사 안됨

 #### 2.1 테이블 데이터 복사 실습

```sql
 create table emp01
 as
 select * from emp;
 ```

 ```sql
 select * from emp01;
 ```

- 테이블 emp 조회 시, 컬럼 empno를 조건으로 걸었을 때 인덱스를 탐
```sql
 select * from emp where empno = 7788;
 --------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    38 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    38 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_EMP |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------
```

- 테이블 emp01 조회 시, 컬럼 empno를 조건으로 걸었을 때 인덱스를 타지 않고 풀스캔을 탐
```sql
 select * from emp01 where empno = 7788;
 ---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     1 |    87 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP01 |     1 |    87 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```

- 테이블 emp는 empno을 PK 인덱스로 가지고 있으나,
  emp01은 emp의 데이터만 복사되고 제약조건 및 인덱스는 복사 안된 것을 실행계획을 통해 확인



### 3. 조건 유형 및 UNIQUE 인덱스 

> 1. where 뒤, 조건의 유형은 5개   
> - point 조건 : =    
> - 범위(Range) 조건 : >,<=    
> - 열거 조건 : in (a,b,c,,,)    
> - 패턴 조건 : like _ , %   
> - 상태 조건 : is null, is not null   
>  
>  2. 일반 인덱스와 UNIQUE 인덱스(고유)  
> - 둘 다 범위 조건에서는 INDEX RANGE SCAN  
> - UNIQUE 인덱스의 경우 한 행만 찾는 = 조건에서는 데이터를 찾게 되면 다음 데이터를 찾지 않아도 되어 INDEX UNIQUE SCAN 가 발생하지만  
> - 일반 인덱스의 경우 다른 곳에도 있을 수도 있으므로 INDEX RANGE SCAN 로 발생한다.  
> - UNIQUE 인덱스 생성 : PK, UK의 제약조건에 의한 인덱스 생성 / create **unique** index idx01_emp01 on emp01(empno); 처럼 UNIQUE 지정  
>  
> 3. 인덱스 순서 지정  
> 앞쪽(ASC)에서 찾을확률이 높은데이터가 있고 뒷쪽(DESC)에서 찾을 확률이 높은 데이터가 있으므로 asc, desc로 선택하여 인덱스를 만들 수 있다 / 오른차순정렬(INDEX_DESC)을 사용하여 거꾸로 읽어나갈수도있다

#### 3.1 조건 유형 및 UNIQUE 인덱스 실습 
- INDEX UNIQUE SCAN
```sql
select * from emp where empno = 7788; 

--------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    38 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    38 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_EMP |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------
```

- INDEX RANGE SCAN
```sql
select * from emp where empno between 7788 and 7600;

---------------------------------------------------------------------------------------
| Id  | Operation                    | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |        |     1 |    38 |     0   (0)|          |
|*  1 |  FILTER                      |        |       |       |            |          |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    38 |     2   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | PK_EMP |     1 |       |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------------
```

- 인덱스 생성(UNIQUE X)
```sql
create index idx01_emp01 on emp01(empno);
```

- INDEX RANGE SCAN
```sql
select * from emp01 where empno = 7788;
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP01       |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX01_EMP01 |     1 |       |     1   (0)| 00:00:01 |
```

- INDEX RANGE SCAN
```sql
select * from emp01 where empno between 7788 and 7600; -
--------------------------------------------------------------------------------------------
| Id  | Operation                    | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |     1 |    87 |     0   (0)|          |
|*  1 |  FILTER                      |             |       |       |            |          |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMP01       |     1 |    87 |     0   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | IDX01_EMP01 |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
```

### 3. 힌트절 별칭사용
- 테이블 별칭을 사용하면 힌트 적용도 안되기 때문에
  힌트가 제대로 적용되었는지 확인해야 한다


#### 3.1. 힌트절 별칭사용 실습
 - 테이블 별칭과 힌트를 함께 사용했을 경우의 비교

```sql
select  /*+ full(emp) */ *
from emp where empno = 7788;

---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     1 |    87 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP01 |     1 |    87 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```

```sql
select  /*+ full(emp) */ *
from emp e where empno = 7788;

--------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    38 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    38 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_EMP |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------
```
- 테이블 별칭을 사용하여 선언된 힌트를 사용하지 못함을 확인함


### 4. 조건이 없는 힌트사용
- 조건이 없는데도 힌트절을 사용하면 옵티마이저가 진행하는대로 진행된다

#### 4.1. 조건이 없는 힌트사용 실습 
```sql
create index idx02_emp01 on emp01(ename);

```

```sql
select /*+ index(emp01 idx01_emp01 ) */ *
from emp01;
```
- 조건절이 아예 없을 때는 힌트절에 인덱스를 지정해도 인덱스를 타지 않고 full scan을 탐

```sql
select * from emp01 where ename='SMITH';

select /*+ index(emp01 idx01_emp01 ) */ *
from emp01 where ename='SMITH';
```
- 힌트에 작성된 인덱스와 조건절에 해당하는 컬럼의 인덱스가 맞지 않는 경우 
- 힌트로 지정된 인덱스 대신 조건절에 존재하는 인덱스(idx02_emp01)를 탐


### 5. 결합인덱스
- 다수 컬럼을 사용하여 인덱스 생성

- 여러 인덱스가 존재하는 경우, 성능이 좋은 인덱스로 실행된다.
- (ename만 걸린 인덱스1과 empno, ename 두개가 걸린 인덱스2가 있을 때 ename 조건 실행시 인덱스 1이 진행)

- 결합인덱스 중 선두 컬럼이 조건에 걸리고 출력데이터가 결합인덱스의 데이터이 있을 경우 인덱스데이터에서 데이터를 모두 찾을 수 있으므로 성능이 좋다 (Heap데이터를 통해 찾지 않아도되므로)
  그렇다고 결합인덱스에 많은 컬럼을 인덱스로 만들면 인덱스페이지가 많아지게 되어 조작에도 성능이 떨어지게 된다.

- 결합인덱스 중 선두 컬럼이 아닌 다른 컬럼으로 조건에 걸리고 출력데이터를 선두 컬럼을 뽑게될 경우 선두 컬림이 조건절에 없으므로 INDEX RANGE SCAN 탈 수 없다
  하지만 HEAP 데이터 전체를 FULL SCAN하지 않고 인덱스데이터를 FULL SCAN 하더라도 데이터를 뽑아낼 수 있으므로 INDEX FULL SCAN이 진행된다. (TABLE FULL SCAN보다 성능이 좋음)

#### 5.1 결합인덱스 실습
-결합인덱스 생성
```sql
create index idx03_emp01 on emp01(empno, ename);
```

```sql
select * from emp01 where empno=7788;

-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP01       |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX01_EMP01 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
``` 
- empno의 인덱스만 가지고있는 IDX01_EMP01가 더 효과적이므로 결합인덱스가 사용되지 않음


```sql
select /*+ index(emp01 idx03_emp01 ) */  *
from emp01 where empno=7788;

-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP01       |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX03_EMP01 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
```


```sql
select ename from emp01 where empno=7788;

--------------------------------------------------------------------------------
| Id  | Operation        | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |             |     1 |    20 |     1   (0)| 00:00:01 |
|*  1 |  INDEX RANGE SCAN| IDX03_EMP01 |     1 |    20 |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------
```
- IDX03_EMP01에 empno, ename를 모두 가지고 있으므로 heap데이터까지 안가도 된다.
- "TABLE ACCESS BY INDEX ROWID" 의 과정이 생략되었음.


```sql
select empno from emp01 where ename='SCOTT';

--------------------------------------------------------------------------------
| Id  | Operation        | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |             |     1 |    20 |     1   (0)| 00:00:01 |
|*  1 |  INDEX FULL SCAN | IDX03_EMP01 |     1 |    20 |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------
```
- 인덱스의 선두컬럼을 기준으로 찾는것이 아니므로 INDEX FULL SCAN으로 탄다 (테이블 풀 스캔보다는 성능이 좋음)




참고 [https://rastalion.me/oracle%ec%97%90%ec%84%9c-sql-%eb%ac%b8%ec%9e%a5%ec%9d%98-%ec%8b%a4%ed%96%89-%ec%9b%90%eb%a6%ac/]
