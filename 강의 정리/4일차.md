

 DBA 자료 사이트 : http://www.gurubee.net/wiki/pages/26743025

# 인덱스 가공
 - 가공된 인덱스 컬럼은 인덱스를 타지 않는다 (where empno -1 = 7787)
 - 자동형변환 되는 형변환들은 인덱스를 타기 힘들다 (where empno  like '7787'  >  스트링으로 자동형변환)
 - 가공되어 인덱스를 타지 않는 쿼리를 힌트절로 태워도 타지 않는다
 - 인덱스 스캔 시작점을 찾을 수 없기 때문에 가공한 컬럼은 인덱스를 정상적으로 사용할 수 없다.

 ## 1. 인덱스 가공

 ```sql
select * from emp where empno -1 = 7787
``

 ```sql
select * from emp04 where to_number(empno) = 7788;
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     1 |    87 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP04 |     1 |    87 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```

```sql

select * from emp04 where to_number(empno) = '7788';
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     1 |    87 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP04 |     1 |    87 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```


## 2. 인덱스 컬럼 like 조건 및 자동형변환 인덱스 컬럼
- 숫자 타입의 컬럼에 like 조건 사용 시 자동으로 형변환된다.
- 자동형변환된 인덱스컬럼은 인덱스를 타지 못한다.

 ```sql
select * From emp where empno like '7788';
--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |     1 |    38 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP  |     1 |    38 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------
-  1 - filter(TO_CHAR("EMPNO")='7788')
```
- 인덱스를 타지 못한다.
- 위처럼 바뀌게 되는데 함수처리된 컬럼(가공된 컬럼)은 인덱스를 타지 못한다.(empno는 숫자고 like는 패턴 즉, 문자처리로 바뀌게 된다.)
- 하지만 함수를 포함하여 인덱스를 태우고 싶다면 함수기반인덱스(FBI)를 태우면 된다
- create index emp04_idx02 on emp04(substr(ename,0,1)); 
- 함수 기반 인덱스 => 조작이 더 어려워진다.(데이터의 변화가 크게 없을때는 고민해도 좋다.)


```sql  
select * From emp03 where ename like 'SCOTT';
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP03       |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | EMP03_INDX1 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
2 - access("ENAME"='SCOTT')
```
- 타입이 동일해서 가공처리가 일어나지 않는다(ename는 문자타입이므로 like를 사용하더라도 형변환이 일어나지 않는다)


```sql
select * From emp03 where ename like 'A%';
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     2 |   174 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP03       |     2 |   174 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | EMP03_INDX1 |     2 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
 2 - access("ENAME" LIKE 'A%')
       filter("ENAME" LIKE 'A%')
```

- 인덱스데이터에서 A기준으로 인덱스를 타서 INDEX RANGE SCAN가 일어남      
  
 ```sql  
select * From emp03 where ename like '_A%';
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     3 |   261 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP03       |     3 |   261 |     2   (0)| 00:00:01 |
|*  2 |   INDEX FULL SCAN           | EMP03_INDX1 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
2 - filter("ENAME" IS NOT NULL AND "ENAME" LIKE '_A%')
```

-데이터파일에 비해 인덱스파일에 데이터의 내용이 많이들어가므로 리프레벨에있는 인덱스파일이 힙데이터파일보다 양이 적다
(그러므로 테이블 full Scan보다는 Index Full Scan이 효과적이다, 그러나 Index Full Scan은 테이블랜덤액세스를 진행하므로 성능이 더 낮아질 수 있다.)

 ```sql
select * From emp03 where ename like '%A%';
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     7 |   609 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP03       |     7 |   609 |     2   (0)| 00:00:01 |
|*  2 |   INDEX FULL SCAN           | EMP03_INDX1 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
2 - filter("ENAME" IS NOT NULL AND "ENAME" LIKE '%A%')
```
- 위와 동일

```sql
select * from emp03 where substr(ename,0,1) = 'S'; 
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     2 |   174 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP03 |     2 |   174 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```
- 형변환으로 인덱스를 못탄다



## 3. IN 조건 사용 (INLIST ITERATOR)
- IN조건은 OR조건을 표현하는 다른 방식
- IN List 개수만큼 Index Range Scan을 반복하는 것이다.


 ```sql
select * From emp where empno in (7521, 7499, 7788); --INDEX UNIQUE SCAN  
---------------------------------------------------------------------------------------
| Id  | Operation                    | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |        |     3 |   114 |     2   (0)| 00:00:01 |
|   1 |  INLIST ITERATOR             |        |       |       |            |          |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMP    |     3 |   114 |     2   (0)| 00:00:01 |
|*  3 |    INDEX UNIQUE SCAN         | PK_EMP |     3 |       |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------------
```
- in을 실행하면 ("EMPNO"=7499 OR "EMPNO"=7521 OR "EMPNO"=7788) 와 똑같다
- or 조건으로 UNIQUE SCAN으로 반복적으로 실행된것(양이많아지면 range scan이나 full로 바뀔수있다._검색량에 따라 실행계획이 바뀔  수 있다)


 ```sql
select * From emp03 where ename IN ('ALLEN','MARTIN','KING');
--------------------------------------------------------------------------------------------
| Id  | Operation                    | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |     3 |   261 |     2   (0)| 00:00:01 |
|   1 |  INLIST ITERATOR             |             |       |       |            |          |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMP03       |     3 |   261 |     2   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | EMP03_INDX1 |     1 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
3 - access("ENAME"='ALLEN' OR "ENAME"='KING' OR "ENAME"='MARTIN')
```
 - ITERATOR란 표현이 나오면 반복처리가 들어간다 생각하면됨 
   

 
 
 
 
 -------------
# 결합인덱스 
 - 결합인덱스에서 선두컬럼을 결정할때 가장많이 식별이 필요한 컬럼을 예측하여 선두에 넣어야한다. (결합인덱스의 순서 중요)
 - 컬럼이 여러개 일때 초반에 필터를 많이 할 수 있는 컬럼을 찾아 선두에 넣어준다(점 조건(포인트 조건, 작은범위 조건) > 선분조건(범위 조건))
 - 자주 사용하는 쿼리 참조
 
 ## RBO규칙 최적화 우선순위
 <img width="688" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/1cf6af8f-8180-4532-ae8b-fca21f2b697c">

- 순위 별로 최적의 성능을 의미하며 여기서 Composite Index(8번)은 결합인덱스를 의미한다.


## 결합인덱스 실습
```sql
create index idx_emp05_01 on emp05(deptno, job);
```
- 결합인덱스 생성

```sql
select * from emp05 where job = 'CLERK' and deptno = 10;
--------------------------------------------------------------------------------------------
| Id  | Operation                   | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |              |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP05        |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_EMP05_01 |     1 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
```
- 인덱스인 두 컬럼으로 조회함

```sql
select job,ename from emp05 where deptno = 10;
--------------------------------------------------------------------------------------------
| Id  | Operation                   | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |              |     3 |    78 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP05        |     3 |    78 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_EMP05_01 |     3 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
```
- 선두 인덱스로 조회하여 INDEX RANGE SCAN 진행됨


```sql
select deptno,ename from emp05 where job = 'CLERK';
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     4 |   104 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP05 |     4 |   104 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```
- 선두 인덱스컬럼으로 조회가되지 않았기에 인덱스를 타지 못한다


```sql
select deptno from emp05 where job = 'CLERK';
---------------------------------------------------------------------------------
| Id  | Operation        | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |              |     4 |    76 |     1   (0)| 00:00:01 |
|*  1 |  INDEX FULL SCAN | IDX_EMP05_01 |     4 |    76 |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------
```
- 결합인덱스에 모두 있기때문에 인덱스스캔만 해도됨


# 클러스터펙토링(CF)
- 일텍스파일에서 힙테이블로 테이블렌덤엑세스를 한 데이터 당 하나씩 하면 성능이 않좋기 때문에 여러개 찾을 것을 한번 엑세스 후 여러개를 읽게되면 효과적인다
 인덱스의 순서와 힙의 순서를 비슷하게 정렬하여 입력이되면 한번 엑세스에 여러개를 읽을 수 있게된다.
