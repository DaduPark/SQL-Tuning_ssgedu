

 DBA 자료 사이트 : http://www.gurubee.net/wiki/pages/26743025

## 인덱스 가공
 - 가공된 인덱스 컬럼은 인덱스를 타지 않는다. (where empno -1 = 7787)
 - 자동형변환 되면 인덱스를 사용할 수 없다. (where empno  like '7787'  >  스트링으로 자동형변환)
 - 가공되어 인덱스를 타지 않는 쿼리는 힌트절을 작성해도 인덱스를 사용할 수 없다.
 - 인덱스 스캔 시작점을 찾을 수 없기 때문에 가공한 컬럼은 인덱스를 정상적으로 사용할 수 없다.

 #### 실습

 #### 1. 가공된 인덱스 사용
- 가공된 인덱스인 경우 인덱스를 사용하지 못하므로 TABLE FULL SCAN을 탄다. 

```sql
select * from emp where empno -1 = 7787
```

 ```sql
select * from emp04 where to_number(empno) = 7788;
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     1 |    87 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP04 |     1 |    87 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```

```sql

select * from emp04 where to_number(empno) = '7788';
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     1 |    87 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP04 |     1 |    87 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```


#### 2. 자동 형변환과 like 조건
- 숫자 타입의 컬럼에 like 조건 사용 시 자동으로 형변환된다.
- 자동형변환된 인덱스컬럼은 인덱스를 타지 못한다.

 ```sql
select * From emp where empno like '7788';
--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |     1 |    38 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP  |     1 |    38 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------
-  1 - filter(TO_CHAR("EMPNO")='7788')
```
- 위처럼 바뀌게 되는데 함수처리된 컬럼(가공된 컬럼)은 인덱스를 타지 못한다.
- empno는 숫자고 like는 패턴이므로 문자로 형변환 처리되어 실행된다.
- 하지만 함수를 포함하여 인덱스를 태우고 싶다면 함수기반인덱스(FBI)를 태우면 된다.
- ex) create index emp04_idx02 on emp04(substr(ename,0,1)); 
- 함수 기반 인덱스 사용 시 조작이 더 어려워질 수 있어 잘 사용하지 않는다. 단, 데이터의 변화가 크게 없을때는 고려해도 좋다.


```sql  
select * From emp03 where ename like 'SCOTT';
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP03       |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | EMP03_INDX1 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
2 - access("ENAME"='SCOTT')
```
- 타입이 동일해서 가공처리가 일어나지 않는다.
- ename는 문자타입이므로 like를 사용하더라도 형변환이 일어나지 않는다.


```sql
select * From emp03 where ename like 'A%';
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     2 |   174 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP03       |     2 |   174 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | EMP03_INDX1 |     2 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
 2 - access("ENAME" LIKE 'A%')
       filter("ENAME" LIKE 'A%')
```

- 인덱스데이터에서 A기준으로 인덱스를 타서 INDEX RANGE SCAN가 일어난다.
  
 ```sql  
select * From emp03 where ename like '_A%';
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     3 |   261 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP03       |     3 |   261 |     2   (0)| 00:00:01 |
|*  2 |   INDEX FULL SCAN           | EMP03_INDX1 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
2 - filter("ENAME" IS NOT NULL AND "ENAME" LIKE '_A%')
```

- 데이터파일에 비해 인덱스파일에 데이터의 내용이 많이들어가므로 leaf 레벨에있는 인덱스파일이 힙데이터파일보다 양이 적다.
- 그러므로 TABLE FULL SCAN보다는 INDEX FULL SCAN이 효과적이다. 단, INDEX FULL SCAN은 테이블랜덤액세스를 진행하므로 성능이 더 낮아질 수 있다.)

 ```sql
select * From emp03 where ename like '%A%';
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     7 |   609 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP03       |     7 |   609 |     2   (0)| 00:00:01 |
|*  2 |   INDEX FULL SCAN           | EMP03_INDX1 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
2 - filter("ENAME" IS NOT NULL AND "ENAME" LIKE '%A%')
```
- 위와 동일

#### 3. 함수 사용

```sql
select * from emp03 where substr(ename,0,1) = 'S'; 
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     2 |   174 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP03 |     2 |   174 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```
- 형변환으로 인덱스를 못탄다



#### 4. IN 조건 사용 (INLIST ITERATOR)
- IN조건은 OR조건을 표현하는 다른 방식.
- IN 조건의 개수만큼 Index Range Scan을 반복한다.


 ```sql
select * From emp where empno in (7521, 7499, 7788); --INDEX UNIQUE SCAN  
---------------------------------------------------------------------------------------
| Id  | Operation                    | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |        |     3 |   114 |     2   (0)| 00:00:01 |
|   1 |  INLIST ITERATOR             |        |       |       |            |          |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMP    |     3 |   114 |     2   (0)| 00:00:01 |
|*  3 |    INDEX UNIQUE SCAN         | PK_EMP |     3 |       |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------------
```
- 위의 in 조건절은 ("EMPNO"=7499 OR "EMPNO"=7521 OR "EMPNO"=7788) 와 같다.
- or 조건으로 UNIQUE SCAN으로 반복적으로 실행된 것.
- 양이많아지면 range scan이나 full로 바뀔 수 있다.
- 검색량에 따라 실행계획이 바뀔 수 있다


 ```sql
select * From emp03 where ename IN ('ALLEN','MARTIN','KING');
--------------------------------------------------------------------------------------------
| Id  | Operation                    | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |     3 |   261 |     2   (0)| 00:00:01 |
|   1 |  INLIST ITERATOR             |             |       |       |            |          |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMP03       |     3 |   261 |     2   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | EMP03_INDX1 |     1 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
3 - access("ENAME"='ALLEN' OR "ENAME"='KING' OR "ENAME"='MARTIN')
```
 - ITERATOR란 표현이 나오면 반복처리가 들어간다 생각하면됨 
   

 
 
 
 
 -------------
## 결합인덱스 
 - 결합인덱스에서 선두컬럼을 결정할 때는 가장 많이 식별이 필요한 컬럼을 예측하여 선두에 넣어야한다. (결합인덱스의 순서 중요)
 - 컬럼이 여러개 일때 초반에 필터를 많이 할 수 있는 컬럼을 찾아 선두에 넣어준다(점 조건(포인트 조건, 작은범위 조건) > 선분조건(범위 조건))
 - 자주 사용하는 쿼리 참조

### 결합인덱스 check!
1. where 조건에 많이 사용되는 컬럼을 우선
2. equal(=)로 사용되는 컬럼을 우선
3. 분포도가 좋은 컬럼을 우선
4. 자주 이용되는 순서대로 결합인덱스의 컬럼의 순서를 결정
 
 ### [참고] RBO 규칙 최적화 우선순위
 <img width="688" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/1cf6af8f-8180-4532-ae8b-fca21f2b697c">

- 순위 별로 최적의 성능을 의미하며 여기서 Composite Index(8번)은 결합인덱스를 의미한다.


#### 실습
```sql
create index idx_emp05_01 on emp05(deptno, job);
```
- 결합인덱스 생성

```sql
select * from emp05 where job = 'CLERK' and deptno = 10;
--------------------------------------------------------------------------------------------
| Id  | Operation                   | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |              |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP05        |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_EMP05_01 |     1 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
```
- 인덱스인 두 컬럼으로 조회함

```sql
select job,ename from emp05 where deptno = 10;
--------------------------------------------------------------------------------------------
| Id  | Operation                   | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |              |     3 |    78 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP05        |     3 |    78 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_EMP05_01 |     3 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
```
- 선두 인덱스로 조회하여 INDEX RANGE SCAN 진행됨


```sql
select deptno,ename from emp05 where job = 'CLERK';
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     4 |   104 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP05 |     4 |   104 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
```
- 선두 인덱스컬럼으로 조회가되지 않았기에 인덱스를 타지 못한다


```sql
select deptno from emp05 where job = 'CLERK';
---------------------------------------------------------------------------------
| Id  | Operation        | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |              |     4 |    76 |     1   (0)| 00:00:01 |
|*  1 |  INDEX FULL SCAN | IDX_EMP05_01 |     4 |    76 |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------
```
- 결합인덱스에 모두 있기때문에 인덱스스캔만 해도됨


## 클러스터링 펙터 (Clustering Factor)
- 군집성 계수(=데이터가 모여있는 정도)
- 데이터베이스에서는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
- "인덱스 클러스터링 팩터가 좋다."라는 것은 인덱스 정렬 순서와 테이블 정렬 순서가 서로 비슷하다는 것을 말한다.
- 인덱스파일에서 힙테이블로 테이블 랜덤 엑세스를 한 데이터 당 하나씩 하면 성능이 안좋기 때문에 여러개 찾을 것을 한번 엑세스 후 여러개를 읽게되면 효과적이다.
- 인덱스의 순서와 힙의 순서가 비슷하게 정렬 되어있으면 한번 엑세스에 데이터 여러 개를 읽을 수 있게된다.
<img width="500" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/e34cb290-2c36-4b6b-b60a-b0e27473e680">

### 클러스터링 팩터의 중요성
1. Index Scan의 Cost에 큰 영향을 준다.
2. Index Lookup을 통해 Data를 읽는 일량을 결정한다.

#### 실습
```sql
select owner, index_name, clustering_factor from all_indexes; 
---------------------------------------------------------------
SCOTT IDX02_EMP01 1
SCOTT IDX01_EMP01 1
OE SYS_C0011037 117
OE SYS_C0011034 168
HR EMP_EMP_ID_PK 2
HR EMP_EMAIL_UK 19
SCOTT PK_EMP 1
```

