
# 학습 목차
- heap이 이해
- B트리구조 인덱스의 이해
------
## 데이터베이스 저장구조
<img src="https://github.com/DaduPark/ReadingRecord/assets/76692927/a56e0a87-2214-4957-90f6-4fc097e3cc61" height="200"/>
<img src="https://github.com/DaduPark/ReadingRecord/assets/76692927/a949321e-57f6-4076-91e1-b29538ba8450" height="200"/>

- 블록 : 데이터를 읽고 쓰는 단위(페이지라고도 불림)
- 익스텐트 : 공간을 확장하는 단위. 연속된 블록 집합
- 세그먼트 : 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
- 테이블스페이스 : 세그먼트를 담는 콘테이너
- 데이터파일 : 디스크 상의 물리적인 OS 파일(DBF)

- 하나의 테이블스페이스에는 여러개의 DBF파일로 이루어져있다
- 성능을 위해서는 시간과 읽기 수를 줄여야한다
> 데이터 조작작업(insert, update, delete) 후 가끔 압축을 해줘야 성능이 좋아짐.  
> 예로 update 시 해당 데이터가 존재하는 페이지에만 간단히 데이터를 수정되는 것이 아니라 페이지 스플릿, 페이지 생성등 작업이 진행되며 페이지가 늘어가게 되어 I/O가 많아 지게 되므로 성능이 저하된다. 이로 인해 압축작업을 진행해줘야한다.

#### [참고] 오라클의 논리적 구성요소
데이터 블록(data blocks) -> 확장 영역(extents) -> 세그먼트(segments) -> 테이블스페이스(tablespace) -> 데이터베이스(database)

#### [참고] 오라클의 물리적 구성요소 : DBF(Data File)
- 오라클 구성정보 파일 위치 => D:\app\(유저명)\oradata\orcl 
- REDOXX.log 파일 => DB에서 물리적으로 데이터가 변하는것을 저장 (DML_insert, update, delete)  
- XX.DBF 파일 (테이블스페이스명) => 테이블 스페이스에서 사용하는 데이터 파일
- USERSXX.DBF 파일 (사용자스페이스명) => 사용자 계정이 사용하는 데이터 파일
![image](https://github.com/DaduPark/SQL-Tuning_ssgedu/assets/134204844/b511a7f0-5557-4fb1-b22d-aa813dbd9426)
-

--------------------
## Heap 및 B트리구조 인덱스의 이해

### Heap
- 데이터가 무작위로 한 줄로 나열하여 페이지에 담긴다.
- 데이터가 무작위이므로 조회성능은 떨어짐
- 데이터 조작(insert, update, delete)을 할 때는 데이터를 무작위로 넣어도 되므로 조작 성능은 좋다.
- 조회 : 데이터페이지 스캔
- Full Scan

### B트리구조 인덱스
- 데이터가 인덱스컬럼 기준으로 트리형태로 페이지에 담긴다.
- 루트및 브랜치에 저장된 각 인덱스 레코드는 하위 블로에 대한 주소값을 갖는다(수직적 탐색이 가능)
- 데이터가 트리형태로 나열되어있으므로 인덱스 컬럼 조건에 맞는 조회를 진행 시 조회성능이 좋다.
- 데이터 조작(insert, update, delete)을 할 때는 리브, 브랜치, 루트 레벨의 전체 페이지에 영향이 갈 수 있으므로 조작성능이 떨어짐(불필요한 인덱스 생성은 줄여야함)
- 인덱스 구조를 한줄로 할 경우 조작할 때 전체 페이지의 수정이 작업되야하므로 db가 다운된다 -> B-tree구조 탄생 (트리구조)
- 조회 : 인덱스페이지 스캔 이후 해당 데이터의 ROWID(페이지주소+페이지 내의 데이터 순번)을 찾아 데이터페이지에서 스캔한다.
- Index Scan

### 인덱스가 존재하는 제약조건
- 제약조건(6개) : PK, UK, FK, Not NULL, CHECK제약, (DEFAULT 제약)
- 인덱스가 걸리는 제약 조건 : PK, UK

### 탐색의 종류 
- 수직적 탐색 : root-> leaf로 스캔
- 수평적 탐색 : 같은 레벨(leaf레벨, branch레벨)에서 다음페이지로 스캔, leaf에서 다음것들 스캔(인덱스스캔 후 RowId를 통해 테이터 스캔 진행)

### 옵티마이저
- 규칙, 비용을 따져서 최적의 조회 성능을 낼 수 있게 도와준다.
   - RBO :  규칙 기반 옵티마이저
   - CBO :  비용 기반 옵티마이저
- 인덱스가 적용된 컬럼이 조건절에 걸렸다고 해도 Index Scan이 Full Scan보다 많아질 경우 옵티마이저가 판단하여 Full Scan(데이터페이지로만 스캔)을 한다.

### 엑세스 성능 향상
- 랜덤엑세스 : 시퀀셜엑세스가 아닌 모든 것 (인덱스 랜덤엑세스, 테이블 랜덤엑세스)
   - 인덱스 랜덤엑세스 : 인덱스 스캔(루트, 브랜치, 리프)으로 랜덤엑세스 되는 것
   - 테이블 랜덤엑세스 : 인덱스 스캔 후 데이터스캔으로 랜덤엑세스 되는 것
- 시퀀셜엑세스 : 순서에 맞춰 찾아가는 것(다음페이지 이전페이지 찾아가는것)
- 성능을 향상시키기 위해서는 랜덤엑세스를 줄여라. (인덱스 랜덤엑세스가 아닌 테이블 랜덤엑세스를 줄이는 것이 성능에 좋다!!)
---------
## 실습
> 가정   
> ROWID = 페이지와 위치만 생각한다.  
> 인덱스에는 키값과 ROWID만 들어간다
> 데이터가 한 파일에 4개가들어가고
> 인덱스는 한 파일에 5개만 들어간다고 생각하고 본다.
>  T1테이블(no, name, ...) 한 로우(데이터)당 2000bytes.

#### 1. heap과 B-트리 구조 인덱스 데이터 저장

<img src="https://github.com/DaduPark/ReadingRecord/assets/76692927/4fcd5048-b1b4-4f50-b343-47da8be3b5c6" height="200"/>

>  => 17개행을 넣는다 > 데이터페이지 5페이지가 필요(4페이지에 4개씩 + 1페이지에 데이터 1개)
>  => 값이 랜덤으로 들어가있을 때 (힙) > table full Scan(값을 찾을때 5페이지를 스캔해야함) 

<img src="https://github.com/DaduPark/ReadingRecord/assets/76692927/01de69f0-b228-44fc-8de4-c742290ad8ff" height="200"/>

>  => 17행을 넣으므로 인덱스페이지(인덱스 기준 : name )는 Leaf 4개(3페이지에 5개씩 + 1페이지에 데이터 1개) + Branch, Root 7개 총 11페이지 필요
> 인덱스를 4페이지(17개)에 name순서에 맞춰서 쓰며 rowId(파일명, 순번)으로 나타냄-> branch 2개의 페이지에 하단의 상의 name을 가지고 만듦 > root 1페이지에 branch 상위 name을 가지고 만듦

#### 2. Search (1. heap과 B-트리 구조 인덱스 데이터 저장 사진 참고)
##### 2.1. Full scan
-  no을 조건절에 건다면 인덱스(name)를 타지 않기 때문에 데이터페이지 5페이지를 찾게된다.

##### 2.2. Index scan
-  name을 조건절에 건다면 인덱스를 타기 때문에 인덱스페이지 3페이지 + 데이터페이지 1페이지, 총 4페이지만 찾게된다.

##### 2.3. 옵티마이저에 의한 Full scan
- (where name between '디비' and '종이')의 조건절을 건다면 12개(Root-branch-leaf 3페이지 + 수평적탐색 + 데이터페이지스캔)
==> 옵티마이저가 인덱스 스캔이 많아질 경우에는 인덱스를 사용 안할 수 있다. 데이터페이지로만 확인함 (full 스캔)


#### 3. Insert('배달'데이터 추가)
##### 3.1. 데이터페이지 수정
<img src="https://github.com/DaduPark/ReadingRecord/assets/76692927/70df7f43-ddd7-4178-b28e-900f5f2e9a88" height="200"/>  

- 데이터 추가 시 데이터페이지는 마지막에 추가하면 됨

##### 3.2. 인덱스 페이지 수정
<img src="https://github.com/DaduPark/ReadingRecord/assets/76692927/a73a0ce2-6377-40a9-a113-8c6d7bdb94c0" height="200"/>  

- 인덱스페이지에는 leaf 레벨에 한장을 더 추가하여(페이지 스플릿_반띵) leaf(추가된 페이지과 기존 페이지를 순서에 맞게 주소값도 변경), branch등 많은 페이지들을 조정한다(페이지 추가 : 205, 페이지 수정 :202, 201)
( 조회에서는 인덱스가 빠르지만 조작관점으로 보면 heap이 성능이 좋다. 그러므로 불필요한 인덱스 생성은 줄여야한다.)


#### 4. Update ('모자'데이터를 '강자'데이터로 변경)
##### 4.1. 데이터페이지 수정
<img src="https://github.com/DaduPark/ReadingRecord/assets/76692927/e21d318d-8b12-4ffe-ae84-5dbdbf026603" height="200"/>  

- 해당 데이터만 수정되면됨
  
##### 4.2. 인덱스 페이지 수정
<img src="https://github.com/DaduPark/ReadingRecord/assets/76692927/a6663dfb-fd7d-49b0-ac12-7f00b72474d3" height="200"/>  

- 201페이지는 페이지 스플릿처리되어 반으로 나뉘게 되고 순서에 맞게 '강자'데이터는 201로 감
- 나머지 반은 206으로 변경
- branch레벨인 301에 206의 가장 상위 데이터가 셋팅됨
- 202에 '모자'데이터 삭제
